name: Release (web)

on:
  push:
    tags:
      - 'v*.*.*'

# Minimize permissions; broaden only if needed
permissions:
  contents: write     # upload release assets, read repo
  packages: write     # push image to GHCR
  id-token: write     # keyless cosign signing

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  HEALTH_ENDPOINT: /health

jobs:
  release:
    name: Build & publish web release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # GHCR requires lowercase image names
      - name: Compute IMAGE_NAME (lowercase)
        run: echo "IMAGE_NAME=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_ENV"

      # --- Build & test the SPA ---
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        env:
          CI: "true"
        run: npm test

      - name: Build web assets
        run: npm run build

      - name: Prepare release artifacts (dist + optional files)
        id: artifacts
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ github.ref_name }}"
          REPO_NAME="${GITHUB_REPOSITORY##*/}"
          mkdir -p artifacts

          # Ensure dist exists then pack it
          test -d dist || { echo "Expected dist/ directory after build"; exit 1; }
          DIST_TGZ="${REPO_NAME}-${TAG}-dist.tar.gz"
          tar --owner=0 --group=0 --mtime='UTC 1970-01-01' -C dist -czf "artifacts/${DIST_TGZ}" .

          # Optional extras (guarded)
          if [[ -f docs/openapi.yaml ]]; then
            OPENAPI_NAME="${REPO_NAME}-${TAG}-openapi.yaml"
            cp docs/openapi.yaml "artifacts/${OPENAPI_NAME}"
            echo "openapi=${OPENAPI_NAME}" >> "$GITHUB_OUTPUT"
          fi

          if [[ -f example.env ]]; then
            EXAMPLE_ENV_NAME="${REPO_NAME}-${TAG}-example.env"
            cp example.env "artifacts/${EXAMPLE_ENV_NAME}"
            echo "example_env=${EXAMPLE_ENV_NAME}" >> "$GITHUB_OUTPUT"
          fi

          if [[ -f deploy/compose.service.yaml ]]; then
            COMPOSE_SNIPPET_NAME="${REPO_NAME}-${TAG}-compose.service.yaml"
            cp deploy/compose.service.yaml "artifacts/${COMPOSE_SNIPPET_NAME}"
            echo "compose_snippet=${COMPOSE_SNIPPET_NAME}" >> "$GITHUB_OUTPUT"
          fi

          # Outputs
          echo "dist=${DIST_TGZ}" >> "$GITHUB_OUTPUT"

      # --- Containerize & push to GHCR ---
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          # derive semver tags from the release tag
          tags: |
            type=semver,pattern={{version}},value=${{ github.ref_name }}
            type=semver,pattern={{major}}.{{minor}},value=${{ github.ref_name }}
            type=semver,pattern={{major}},value=${{ github.ref_name }}
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=${{ github.event.repository.name }}
            org.opencontainers.image.description=Static React build served by Node runtime
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Build & push multi-arch image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true

      - name: Print image digest
        run: echo "Pushed digest ${{ steps.build.outputs.digest }}"

      # --- SBOM & Signing ---
      - name: Generate SBOM (SPDX JSON) for image@digest
        id: sbom
        uses: anchore/sbom-action@v0.20.0
        with:
          image: ${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          format: spdx-json
          output-file: artifacts/sbom-${{ steps.build.outputs.digest }}.spdx.json

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.0

      - name: Sign container image (keyless)
        run: |
          set -euo pipefail
          IMAGE_REF="${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
          cosign sign --yes "$IMAGE_REF"

      - name: Download image provenance attestation
        id: provenance
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts
          IMAGE_REF="${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
          DIGEST_SAFE="${{ steps.build.outputs.digest }}"
          DIGEST_SAFE="${DIGEST_SAFE//:/-}"
          PROVENANCE_FILE="provenance-${DIGEST_SAFE}.intoto.jsonl"
          if cosign download attestation --predicate-type slsaprovenance "$IMAGE_REF" > "artifacts/${PROVENANCE_FILE}"; then
            echo "asset_name=${PROVENANCE_FILE}" >> "$GITHUB_OUTPUT"
          else
            echo "No provenance attestation available for ${IMAGE_REF}; skipping artifact."
            rm -f "artifacts/${PROVENANCE_FILE}"
            echo "asset_name=" >> "$GITHUB_OUTPUT"
          fi

      # --- Release notes (script if present; else minimal default) ---
      - name: Compose release notes
        id: notes
        shell: bash
        env:
          RELEASE_TAG: ${{ github.ref_name }}
          IMAGE_REF: ${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          IMAGE_DIGEST_REF: ${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          DIST_ARCHIVE_NAME: ${{ steps.artifacts.outputs.dist }}
          SBOM_NAME: sbom-${{ steps.build.outputs.digest }}.spdx.json
          PROVENANCE_NAME: ${{ steps.provenance.outputs.asset_name }}
          OPENAPI_ASSET_NAME: ${{ steps.artifacts.outputs.openapi }}
          EXAMPLE_ENV_ASSET_NAME: ${{ steps.artifacts.outputs.example_env }}
          COMPOSE_SNIPPET_ASSET_NAME: ${{ steps.artifacts.outputs.compose_snippet }}
        run: |
          set -euo pipefail
          mkdir -p artifacts
          if [[ -f scripts/build-release-notes.mjs ]]; then
            node scripts/build-release-notes.mjs | tee artifacts/release-notes.md
          else
            cat > artifacts/release-notes.md <<'EOF'
            ## Web release

            - Built and pushed multi-arch image to GHCR
            - Generated SBOM (SPDX JSON)
            - Image signed via cosign (keyless)
            - See assets for dist tarball and checksums

            EOF
          fi

      - name: Generate checksums
        run: |
          (cd artifacts && shasum -a 256 * > SHA256SUMS || true)

      # --- Upload GitHub Release assets (attach to the already-published release) ---
      - name: Upload release assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          body_path: artifacts/release-notes.md
          files: |
            artifacts/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Also keep a copy in the workflow run for quick debugging
      - name: Upload debug bundle (artifacts/)
        uses: actions/upload-artifact@v4
        with:
          name: dist-and-metadata-${{ github.ref_name }}
          path: artifacts
          if-no-files-found: ignore
